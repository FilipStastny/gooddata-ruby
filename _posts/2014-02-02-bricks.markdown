---
layout: post
title:  "Executing ruby on GoodData plaform"
date:   2014-01-19 13:56:00
categories: recipe
prev_section: recipe/test-driven-development
pygments: true
perex: ETL is the back bone of every project. But project is not just about crunching numbers. What to do with tasks that are very well suited for solving by a regular programming language, like Ruby?
---

You can run Ruby on GoodData platform. Let's have a look at the platform and walk step by step through doing the simplest possible deployment and then move to more advanced tasks.

##Not reinventing the wheel

The main idea is that only minority of people should be forced to write code. The others should be happy running them without understanding the details. We will introduce better UI soon to do that. Until then it is more programatic but if you are not scared read on.

##Setting up the stage

GoodData Ruby SDK stack is built so you can easily develop things locally and deploy them when you have tested them and are happy with how they work. You need to set up an environment first.

###Prerequisites

* Git
* Ruby 1.9 and later (JRuby recommended)
* Ruby Gems

Go ahead and run

{% highlight ruby %}
git clone https://github.com/gooddata/app_store.git
{% endhighlight %}

We just cloned the remote repository which contains information about the used libraries and also contains some stuff that others created. We will investigate that later. Let's continue with setting things up. Run following code

{% highlight ruby %}
gem install bundler
{% endhighlight %}

This will install bundler which is a useful package installation tool. Let's use it

{% highlight ruby %}
cd local_repo
bundle install --binstubs
{% endhighlight %}

This will ensure that you have installed exactly what we have on the production machines. This should **mitigate bugs** caused by slightly different versions of libraries and incompatible APIs.

You are ready to go!

##Running your first brick

The small pieces of ruby that are run on the platform are called **bricks**. Nobody knows where and why this name emerged but there are rumors that it is supposed to reference the fact that out of brick just laid together you can create a solid wall like with Legos.

If you open the repository you will see some directories. Find directory called app/hello_world and open it. It contains only one file. Do not open it yet.

Run following console command

{% highlight ruby %}
bin/gooddata -l -U name@gooddata.com -P my_pass -p project_pid run_ruby -d hello_world_brick --name "Hello_world" --remote
{% endhighlight %}

It will take some time but after a while you should see green DONE on your console and a link for the log. Open it in your browser (on mac Hold Command+double click your mouse on the link) and you should see there something like this: On one of the lines there should be hello world. Great you just ran your first ruby brick!

###Looking inside Hello World

Let's see what is happening inside. Open the `main.rb` file in your favorite editor. You should see something like:

{% highlight ruby %}
puts "Hello world"
{% endhighlight %}

That's all! All you really have to do is write the code. Everything that goes to STDOUT is automatically logged as an infor level log output. As we will see later this is great but for something more complex we could be a little smarter. Please note that it is in the file called main.rb though it is not technically necessary all examples that we show follows this convetion and it allows people to know where to look.

##Digging deeper

It might be surprising if I tell you that this is not exactly how majority of the real bricks are implemented. What we showed you is fine and this is how we started but after we implemented some bricks we found out that we are repeating ourselves a lot. So we tried to come up with something better. How can we reuse common things that we are likely to do every single time (like logging to GD) without repeating ourselves? We took our inspiration from Rack or if you are familiar with Decorator pattern you will be right at home. 

We introduce something we call **application**. This is what is responsible for carrying out the core of our business requirement. For example printing hello world or grabbing all the reports and tagging those who were not updated in last year for review. There is also something we call **middleware** which is responsible to do something like logging into GoodData. Both of those have the same interface so from the outside I cannot tell if I am interacting with one or the other. The only difference is that middleware knows there is somebody else who expects that is going to be called and it is middleware's responsibility to call him. This chain of middlewares and an application is called a pipeline.

Let's have a look at something visual. This is a simple pipeline with 2 middlewares and one app. The arrows depict how the execution order would flow.

![Example pipeline consisting of 3 middlewares](https://dl.dropboxusercontent.com/s/g5rymdmmx97hc61/middlewares.png?token_hash=AAE7qAjkOxA6tQGDk8UY17ltRu0ZG5UqwSJ_8ZtAl7ZNaA)

Let's wark through the pieces. Let's imagine for a second that we are going to reimplement the hello world like this

{% highlight ruby %}
require 'gooddata'
require 'logger'

module GoodData::Bricks
  class HelloWorldBrick

     def call(params)
       puts "Hello world"
     end

  end
end

GoodData::Bricks::HelloWorldBrick.new.call($SCRIPT_PARAMS)
{% endhighlight %}

Like we said before the important thing is that our app has an interface. The one we have here is very simple. You have to provide an instance of an object that responds to a message `:call` (in other words does implement method named call). This method takes one parameter and that is a hash map of parameters. This is going to be our interface so you should not be surprised if you would see the same interface when we will later look at some middlewares. Like we said they have to have the same interface for this to work.

##Middlewares

Let's have a look at some middlewares.

App was not very challenging from programming perspective (which is the goal) and you will see that middleware is not any more complicated. There are generally two types of middlewares. First is a middleware that wants to act only once. It is like fire and forget. For example setting up logger. You just create it and do not care any more. There is a second type and that is a middleware that wants to act twice. Once before the app itself was called. Second after an app was called. Typical example might be time measuring. You want to start your clock before the app itself is called but then you have to stop them sometimes. The difference is absolutely minimal let's walk through both of them.

###Logger middleware

{% highlight ruby %}
require 'logger'
	
module GoodData::Bricks
  class LoggerMiddleware < GoodData::Bricks::Middleware
	
    def call(params)
      logger = params[:gdc_logger] = params[:GDC_LOGGER_FILE].nil? ? Logger.new(STDOUT) : Logger.new(params[:GDC_LOGGER_FILE])
      logger.info("Pipeline starts")
	
      returning(@app.call(params)) do |result|
        logger.info("Pipeline ending")
      end
    end
	
  end
end
{% endhighlight %}

###Benchmarking middleware

{% highlight ruby %}
require 'benchmark'
	
module GoodData::Bricks
	
 class BenchMiddleware < GoodData::Bricks::Middleware

   def call(params)
      puts "Starting timer"
      result = nil
      report = Benchmark.measure { result = @app.call(params) }
      puts "Stopping timer"
      pp report
      result
    end
	
  end
end
{% endhighlight %}

You can see that there are really only minimal changes. Let's walk through a couple of important points more carefully. As we stated before difference between app and a middleware is mainly in the fact that you can chain middelewares. Thus middleware has to know who is the next on in the chain and at some point it is going to call him. That is the `@app.call(params)`. Notice how we are still using the same interface. This way it is no difference if the next guy is app or middleware. The second important piece might be the returning function but that is just a way how to be more dry. Returning will take one param evaluate it store it you can do some stuff on it and then its value is returned. These things are equivalent.

{% highlight ruby %}
returning(Person.new) do |o|
  p.name = "Tomas"
end
	
p = Person.new
p.name = "Tomas"
p
{% endhighlight %}

##Putting it all together - Pipeline

Like we said before. Pipeline is something that puts the middlewares and and application together. We created a helper function that takes the classes (or you can provide the instances) and it joins them together. For example ike this.

{% highlight ruby %}
p = GoodData::Bricks::Pipeline.prepare([
  LoggerMiddleware,
  BenchMiddleware,
  GoodDataMiddleware,
  RestForceMiddleware,
  BulkSalesforceMiddleware,
  SalesForceHistoryBrick])
{% endhighlight %}

p again has the same interface as a middleware or an app. Just call it and it will run the whole pipeline. This is not surprising since it actually just returns you the first middleware instance. So to call the whole pipeline we run something like this.

{% highlight ruby %}
p.call($SCRIPT_PARAMS)
{% endhighlight %}

##Local harness

Let's talk a little about the harness that makes it possible to test things locally. It tries to run your bricks in similar environment as it would run on the server. This mainly means that you will get the same parameters etc. The goal is to provide you environment to debug and test before you deploy.

###Run locally

As you might have noticed when you installed gooddata ruby sdk it installed a CLI tool that has number of cool utilities that makes some tasks easier. One of those is running ruby bricks locally. The most complete command is
    
{% highlight ruby %}
bin/exec gooddata -lv -s https://secure.gooddata.com -Uname@gooddata.com -Pmy_pass -w https://secure-di.getgooddata.com -p rjzbt1shubkj9c8es6f75t2avke748mj run_ruby -d brick_test --name "some_deploy" --params brick_test/params.json 
{% endhighlight %}

looks intimidating but let's break it down. Many of these can be omitted in default case and are mentioned here in case you need to override the default.

{% highlight ruby %}
bin/exec
{% endhighlight %}

when you installed the tooling through `bundle install --binstubs` it created local executables in local bin directory. It basically means you are executing it with exact the same libraries as you would on the server (we are expecting that your local repo is up to date).

{% highlight ruby %}
 -l
{% endhighlight %}

Means that HTTP communication will be logged to STDOUT.

{% highlight ruby %}
 -v
{% endhighlight %}

Runs in a verbose mode.

{% highlight ruby %}
 -s https://secure.gooddata.com
{% endhighlight %}

Means which datacenter you are connecting to. If you are not running against something special you should be able to leave this out our servers will figure out where to send you.

{% highlight ruby %}
 -w https://secure-di.getgooddata.com
{% endhighlight %}

File staging area used for uploading the files for execution. Similar case as for he server. By default you should not be forced to use it.

{% highlight ruby %}
 -p PID
{% endhighlight %}

Currently only execution context we have is project context. You have to specify a project `PID` to be able to run your brick.

{% highlight ruby %}
 -d path_to_brick
{% endhighlight %}

This tells the tool where the brick lives. It expect the directory where the `main.rb` lives. Do not point this directly to a file. Though it is not technically necessary the file to be called main.rb it is a convention that we are exepecting.

{% highlight ruby %}
 --name some_name
{% endhighlight %}

Used when deployed to name the process so later you can identify it.

###Run remotely

The only change to do when you are running things remotely is to add `--remote` to the command. Everything else should remain the same.